---
layout: post
title: BA
subtitle: Graph based SSL
gh-repo: 4someday/4someday.github.io
gh-badge: [star, fork, follow]
tags: [SSL]
---

본 포스팅에서는 semi-supervised learning 방법 중 하나인 Graph based-SSL을 다룰 예정입니다.
 글의 전체적인 내용은 고려대학교 강필성 교수님의 Business-Analytics 강의를 참고하였음을 밝힙니다. 또한 M Hein의 강의자료를 참고함도 밝힙니다.

---

### 가정

먼저 가정에 대해서 알아봅시다.

**가정 : heavy edge로 연결된 인스턴스들은 같은 라벨을 가질 확률이 높다**

Cluster assumption: points which can be connected via (many) paths
through high-density regions are likely to have the same label.



Manifold assumption: each class lies on a separate manifold.





즉, manifold 상의 높은 밀도 지역을 통과하는 path로 연결된 포인트들은 같은 라벨을 가질 확률이 높다는 것입니다


위 그림과 같이 그래프를 그렸을 때 관계가 있는 데이터이면 갖은 라벨을 갖게 해주는 것입니다.

![bandicam 2018-11-25 21-11-39-754 (2) (2)](https://github.com/4someday/4someday.github.io/blob/master/img/20181225_211619.png?raw=true)

___

### Graph construction

Graph-based SSL은 Graph를 기반으로 계산이 됩니다. 베이스로 하는 그래프는 노드와 엣지로 구성이 됩니다.

노드는 라벨된 데이터와 라벨이 되지 않은 데이터 둘 다 포함하는 것입니다. 

엣지는 feature를 통해 계산된 similarity weight입니다.

- k-nearest-neighbor graph, unweighted (0,1 weights)
- fully connected graph, weight decays with distance)
 $ { w }_{ ij }\quad =\quad exp(\frac { { -\left\| { x }_{ i }-{ x }_{ j } \right\|  }^{ 2 } }{ { \sigma  }^{ 2 } } )  $

- epsilon-radius graph


___

### code

''' python
"import os
import numpy as np
import numpy.linalg as lin
import pandas as pd
import matplotlib.pyplot as plt
from scipy import sparse 
from scipy.sparse.linalg import inv
from scipy.spatial import distance

# In[4]:

#Class를 나눠 주는 작업과 각 Class를의 index에 대한 정보 저장하기
class1_idx = (data['V3'] == '1')
class2_idx = (data['V3'] == '2')
labeled_idx = (class1_idx | class2_idx)
unlabeled_idx = (labeled_idx != True)


# In[27]:

class1_idx


# In[6]:

#String 정보를 숫자로 바꿔 주기
num_samples = data.shape[0]
y = np.zeros(shape=(num_samples))
y[class1_idx] = 1
y[class2_idx] = 2
y[unlabeled_idx] = 0 
data['V3'] = y


# In[7]:

#행렬로 변환
lenght = len(y)
Yl = np.full((lenght,1),0)
Yl[class1_idx] = 1
Yl[class2_idx] = 2
labeled_lenght = len(y[labeled_idx])


# In[8]:

# RBF kernal 함수에 사용할 Distance Matrix 만들기
euc = distance.cdist(data.iloc[:, :2], data.iloc[:, :2], 'sqeuclidean')


# In[9]:

# e_radius 함수 만들기
def e_radius(euc, epsilon):
    if epsilon <= 0:
        print('Use epsilon >= 0')
        return None
    e_distance = np.where(euc < epsilon, euc, np.inf)
    return e_distance


# In[10]:

# e_radius 함수를 가지고 w_matrix 만들기
def RBF_Weight(euc, epsilon, gamma):
    euc = e_radius(euc, epsilon)
    
    #RBF
    w_matrix = np.exp(-euc*gamma) #시그마 제곱 대신 gamma를 사용한다(시그마 제곱의 역수).
    np.fill_diagonal(w_matrix,0)
    return w_matrix

W = RBF_Weight(euc, epsilon = 1, gamma = 20)


# In[11]:

W


# In[12]:

# Diagonal Dgree Matrix 만들기
rowsum = W.sum(axis=1)
D = sparse.diags(rowsum)


# In[13]:

# Laplacian Matrix 만들기
L = D - W
" '''
